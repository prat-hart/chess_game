def evaluation(board_state):
  #evaluates piece cost for each and factors in the amount of legal moves for each potential piece
  #more movment possiblities, better score

  piece_cost={'p':1,'r':5,'t':3,'b':3,'q':9,'P':-1,'R':-5,'T':-3,'B':-3,'Q':-9, 'k':100, 'K':-100, '.':0}
  compute_cost = np.vectorize(lambda x: piece_cost[x])
  board_total=compute_cost(board_state).sum()
  
  pieces_b,moves=GetPiecesWithLegalMoves(board_state,'black')
  board_total+=sum([len(m) for m in moves])

  pieces_w,moves=GetPiecesWithLegalMoves(board_state,'white')
  board_total-=sum([len(m) for m in moves])

  return board_total

def GetMinMaxMove(board_state,player,depth=2,cur_move=[0,0]):
  pieces,destinations= GetPiecesWithLegalMoves(board_state,player)

  if depth==0 or pieces==[]:
    return evaluation(board_state),cur_move

  if player == 'black':
    best_score=-1e6
    best_move=cur_move
    for i,piece in enumerate(pieces):
      for destination in destinations[i]:
        moves=MovePiece(board_state,piece,destination)
        scores,move=GetMinMaxMove(moves,'white',depth-1,[piece,destination])
        best_score=max(best_score,scores)
        best_move=[piece,destination] if best_score == scores else best_move
    return best_score,best_move
    
  elif player == 'white':
    best_score=1e6
    best_move=cur_move
    for i,piece in enumerate(pieces):
      for destination in destinations[i]:
        moves=MovePiece(board_state,piece,destination)
        scores,move=GetMinMaxMove(moves,'black',depth-1,[piece,destination])
        best_score=min(best_score,scores)
        best_move=[piece,destination] if best_score == scores else best_move
    return best_score,best_move
    
def GetAlphaBeta(board_state,player,alpha=-1e6,beta=1e6,depth=2,cur_move=[0,0]):
  #extra credit MINMAX with Alpha Beta Pruning
  pieces,destinations= GetPiecesWithLegalMoves(board_state,player)

  if depth==0 or pieces==[]:
    return evaluation(board_state),cur_move

  if player == 'black':
    best_score=-1e6
    best_move=cur_move
    for i,piece in enumerate(pieces):
      for destination in destinations[i]:
        moves=MovePiece(board_state,piece,destination)
        scores,move=GetAlphaBeta(moves,'white',alpha,beta,depth-1,[piece,destination])
        best_score=max(best_score,scores)
        alpha=max(alpha,best_score)
        best_move=[piece,destination] if best_score == scores else best_move
        if best_score >= beta:
          break
    return best_score,best_move
    
  elif player == 'white':
    best_score=1e6
    best_move=cur_move
    for i,piece in enumerate(pieces):
      for destination in destinations[i]:
        moves=MovePiece(board_state,piece,destination)
        scores,move=GetAlphaBeta(moves,'black',alpha,beta,depth-1,[piece,destination])
        best_score=min(best_score,scores)
        beta=min(beta,best_score)
        best_move=[piece,destination] if best_score == scores else best_move
        if best_score <= alpha:
          break
    return best_score,best_move
